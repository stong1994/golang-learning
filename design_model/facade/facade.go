package facade
/*
外观模式
1. 定义：
	外部与一个子系统通信必须通过一个统一的对象进行，为子系统中的一组接口提供一致界面。
2. 实现步骤：
	定义内部模块
	定义对外交互接口及实现
3. 使用场景：
	当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。
	客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。
	在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。
4. 优点：
	对客户屏蔽子系统组件
	实现了子系统与客户之间的松耦合关系
5. 缺点：
	不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。
	在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。
 */

// 外部接口/门面接口
type FaceApi interface {
	Get()
}

type faceXx struct {
	sub SubApi
}

func (f *faceXx) Get() {
	f.sub.Xx()
}

// 定义子系统的接口和方法
type SubApi interface {
	Xx()
}

type SubXx struct {}

func (*SubXx) Xx() {
	return
}

