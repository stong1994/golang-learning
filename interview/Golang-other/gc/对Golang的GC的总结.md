## 关于GC的历程

版本 | GC方法
---|---
1.1 | STW
1.3 | 标记-清除
1.5 | 三色标记法
1.9 | 混合写屏障
未来 | 分代

**GC的触发条件**
- gcTriggerAlways: 强制触发GC
- gcTriggerHeap: 当前分配的内存达到一定值就触发GC
- gcTriggerTime: 当一定时间没有执行过GC就触发GC
- gcTriggerCycle: 要求启动新一轮的GC, 已启动则跳过, 手动触发GC的runtime.GC()会使用这个条件


> 三色标记法：GC时，把对象放在3个区域，分别是白、灰、黑
>> 0. 在进入GC时，所有对象都在白色区域
>> 1. 从根对象开始扫描，将所有可达的对象放入灰色区域。
>> 2. 新产生的对象放在灰色区域
>> 3. 扫描灰色区域中的对象，将可达的子对象全部放到灰色区域，然后将这个对象放到黑色区域。
>> 4. 重复步骤3直到扫描完所有灰色区域，然后将灰色区域中剩下的对象放入黑色区域
>> 5. 此时灰色区域为空，然后回收白色区域中的对象
>> 6. 最后，黑色区域和白色区域互换颜色，等待下一次GC

> 一次GC需要两次STW
>> 1. 扫描根对象， 启动写屏障(Write Barrier)和辅助GC(mutator assist).
>> 2. 完成标记阶段，重新扫描部分根对象，禁用写屏障(Write Barrier)和辅助GC(mutator assist). （这一点会在将来被去除）
>>> 不是所有根对象的扫描都需要STW, 例如扫描栈上的对象只需要停止拥有该栈的G.

* 低延迟牺牲的是吞吐量

关于三色标记法，可查看：https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice/

### 写屏障(Write Barrier)
> 因为go支持并行GC，GC在扫描时，运行的程序可能更改了对象的依赖树。

> 比如有对象A、B、C，C依赖B（B有C的指针），在扫描了A之后，B把C的指针给了A，再扫描B，此时就不会扫描到C。

> 为了避免这种现象，go在GC时会开启写屏障。

> 启动了写屏障后，当B把C的指针交给A后，GC会认为在这一轮的扫描中，C的指针时存活的。

> 写屏障只针对指针使用，而且只在GC标记阶段启用。

go在1.9版本中启用了混合写屏障，混合写屏障会同时标记指针写入”原指针“和”新指针“

混合写屏障可以让GC在并行标记结束后不需要重新扫描各个G的堆栈, 可以减少Mark Termination中的STW时间.

除了写屏障外, 在GC的过程中所有新分配的对象都会立刻变为黑色

### 辅助GC(mutator assist)

> 为了防止heap增速太快, 在GC执行的过程中如果同时运行的G分配了一定大小的内存, 那么这个G会被要求辅助GC做一部分的工作.

> 辅助GC做的工作有两种类型, 一种是标记(Mark), 另一种是清扫(Sweep).

### 混合写屏障
> 混合写屏障会同时标记指针写入目标的“原指针”和“新指针”，来避免重复扫描各个Gorutine堆栈的时间，大幅度缩减标记完成时的STW时间。

推荐文章：https://www.cnblogs.com/zkweb/p/7880099.html