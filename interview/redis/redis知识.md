# redis知识

### 1. 运用场景

1. **做缓存**. 由于其高效的读写,因此适合做数据层的缓存,防止数据库因访问量过大而崩溃
2. **做临时的数据库**.有些数据不需要持久化,那么就可以放到redis中,比如从数据库中获取的数据,经过逻辑处理后存入redis中,等待客户端调用.(**redis不适合做数据库的原因**:大概是传统的数据库更方便统计数据以及reids需要占用大量内存,数据越多,占用内存就越大;redis的持久化是定时持久化,有可能造成数据缺失)
3. **存放并发数据**:由于其单线程的特点,所以是并发安全的,所以在遇到并发量大的场景(如秒杀),可以将数据存入redis 中.

### 2. 数据类型

1. 字符串
2. 列表
3. 哈希
4. 集合
5. 有序集合

### 3. 底层数据结构

1. SDS简单动态字符串
2. 链表
3. 压缩列表
4. 整数集合
5. 字典
6. 跳跃表

### 4. 常见问题

1. **缓存穿透**

   > 缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。每次都要去数据库再查询一遍，然后返回空，这样请求就绕过缓存直接查数据库，如果恶意请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

   1.最常见的则是采用**布隆过滤器**，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

   2.也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。

2. **缓存雪崩**

   > 由于原有缓存失效，新缓存未到,大量的数据访问导致数据库崩溃

   1. 通过加锁的方式控制读写数据库的访问数量
   2. 设置二级缓存
   3. 给key设置不同的过期时间

3. 缓存击穿

   > 缓存击穿与缓存雪崩类似,区别在于缓存雪崩对应的是多个key缓存消失,而缓存击穿是对应一个key缓存消失,因此缓存击穿常出现于热点数据,大量的数据访问导致数据库崩溃

   1. 通过加锁的方式控制数据库的访问